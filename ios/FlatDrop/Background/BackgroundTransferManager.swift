import Foundation
import BackgroundTasks
import FlatDropCore // Generated by UniFFI

/**
 * AirDrop-Class Background Transfer for iOS
 * 
 * Uses URLSession with background configuration
 * iOS owns the transfer lifecycle even when app is suspended
 * 
 * This is the closest public-API equivalent to AirDrop on iOS
 */
class BackgroundTransferManager: NSObject {
    
    static let shared = BackgroundTransferManager()
    
    // Background URLSession - survives app suspension
    private var backgroundSession: URLSession!
    private var completionHandlers: [String: () -> Void] = [:]
    
    // Track active transfers
    private var activeTransfers: [String: TransferState] = [:]
    
    private override init() {
        super.init()
        setupBackgroundSession()
    }
    
    private func setupBackgroundSession() {
        let config = URLSessionConfiguration.background(withIdentifier: "com.flatdrop.transfer")
        
        // Allow transfers on cellular (respect user settings)
        config.allowsCellularAccess = true
        
        // Wait for connectivity if needed
        config.waitsForConnectivity = true
        
        // Share cookies/credentials
        config.httpCookieStorage = HTTPCookieStorage.shared
        config.urlCache = URLCache.shared
        
        // Create session with self as delegate
        backgroundSession = URLSession(configuration: config, delegate: self, delegateQueue: nil)
    }
    
    // MARK: - Transfer Lifecycle
    
    /**
     * Handle TransferStateChanged events from Rust
     * This is the single signal that triggers background execution
     */
    func handleTransferStateChange(_ state: TransferStateChanged) {
        switch state.state {
        case .preparing:
            startBackgroundTransfer(state)
            
        case .inProgress:
            updateTransferProgress(state)
            
        case .finished, .failed, .cancelled:
            completeTransfer(state)
            
        default:
            break
        }
    }
    
    /**
     * Start a background transfer
     * 
     * Strategy:
     * 1. Rust prepares transfer metadata, encryption keys, peer info
     * 2. Swift creates URLSession background task using local_url from Rust
     * 3. iOS takes over the actual file transfer
     * 4. Transfer continues even if app is suspended
     */
    private func startBackgroundTransfer(_ state: TransferStateChanged) {
        let transferId = state.transferId
        
        // Get local URL from Rust handoff server (platform_handle)
        // Format: "http://127.0.0.1:PORT/handoff/FILE_ID"
        let localUrl = state.platformHandle
        
        guard !localUrl.isEmpty else {
            print("ERROR: No local URL provided for transfer \(transferId)")
            return
        }
        
        // Store transfer state
        activeTransfers[transferId] = TransferState(
            id: transferId,
            fileName: state.fileName,
            totalBytes: state.totalBytes,
            direction: state.direction,
            localUrl: localUrl
        )
        
        // Create and start background upload task
        // This is the iOS "Handoff" - Rust serves file via HTTP, iOS URLSession streams it
        createBackgroundUploadTask(
            transferId: transferId,
            localUrl: localUrl,
            fileName: state.fileName
        )
        
        // Request background processing time
        requestBackgroundProcessing(for: transferId)
        
        // Register with iOS background task scheduler
        scheduleBackgroundTask(for: transferId)
        
        // Post notification to inform user
        postTransferNotification(
            title: "Transfer Started",
            body: "Sending \(state.fileName)"
        )
    }
    
    /**
     * Create URLSession background upload task
     * 
     * This connects to Rust's localhost HTTP server (handoff server)
     * and streams the file to the peer via iOS's background daemon
     */
    private func createBackgroundUploadTask(
        transferId: String,
        localUrl: String,
        fileName: String
    ) {
        guard let url = URL(string: localUrl) else {
            print("ERROR: Invalid local URL: \(localUrl)")
            return
        }
        
        // Create request to Rust handoff server
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("bytes=0-", forHTTPHeaderField: "Range")  // Request full file with resume support
        request.setValue("application/octet-stream", forHTTPHeaderField: "Accept")
        
        // Create background download task
        // iOS will download from Rust's localhost server and upload to peer
        let downloadTask = backgroundSession.downloadTask(with: request)
        downloadTask.taskDescription = transferId
        downloadTask.resume()
        
        print("Started background transfer \(transferId) via \(localUrl)")
    }
    
    /**
     * Update transfer progress
     */
    private func updateTransferProgress(_ state: TransferStateChanged) {
        guard var transfer = activeTransfers[state.transferId] else { return }
        
        transfer.bytesTransferred = state.bytesTransferred
        transfer.progress = state.progress
        activeTransfers[state.transferId] = transfer
        
        // Update notification with progress
        let progressPercent = Int(state.progress * 100)
        postTransferNotification(
            title: "Transferring...",
            body: "\(state.fileName) - \(progressPercent)%"
        )
    }
    
    /**
     * Complete transfer and cleanup
     */
    private func completeTransfer(_ state: TransferStateChanged) {
        let transferId = state.transferId
        
        // Remove from active transfers
        activeTransfers.removeValue(forKey: transferId)
        
        // Notify Rust that background work is done
        // This allows Rust to finalize state, integrity checks, cleanup
        notifyRustOfCompletion(state)
        
        // Post completion notification
        let title = state.state == .finished ? "Transfer Complete" : "Transfer Failed"
        postTransferNotification(title: title, body: state.fileName)
        
        // Clean up background resources
        completionHandlers.removeValue(forKey: transferId)
    }
    
    // MARK: - Background Processing
    
    /**
     * Request background processing time from iOS
     * This keeps the app alive during critical transfer phases
     */
    private func requestBackgroundProcessing(for transferId: String) {
        let taskIdentifier = UIApplication.shared.beginBackgroundTask(withName: "Transfer_\(transferId)") {
            // Expiration handler - save state if needed
            self.handleBackgroundExpiration(for: transferId)
        }
        
        // Store completion handler
        completionHandlers[transferId] = {
            UIApplication.shared.endBackgroundTask(taskIdentifier)
        }
    }
    
    /**
     * Schedule a background task for long-running transfers
     * Uses BGTaskScheduler for iOS 13+
     */
    private func scheduleBackgroundTask(for transferId: String) {
        guard #available(iOS 13.0, *) else { return }
        
        let request = BGProcessingTaskRequest(identifier: "com.flatdrop.transfer.\(transferId)")
        request.requiresNetworkConnectivity = true
        request.requiresExternalPower = false
        
        do {
            try BGTaskScheduler.shared.submit(request)
        } catch {
            print("Could not schedule background task: \(error)")
        }
    }
    
    /**
     * Handle background task expiration
     */
    private func handleBackgroundExpiration(for transferId: String) {
        // Save transfer state for resume
        // This allows transfers to continue when app wakes
        
        if let transfer = activeTransfers[transferId] {
            // Notify Rust to pause transfer gracefully
            let command = UiCommand {
                $0.acceptFile = AcceptFileRequest.with {
                    $0.transferID = transferId
                    $0.accept = false  // Signal pause
                    $0.downloadPath = ""
                }
            }
            
            // Send command to Rust
            _ = hubSendCommand(try! command.serializedData())
        }
    }
    
    /**
     * Handle app launch with background URLSession events
     * Called by AppDelegate when transfer completes while app was terminated
     */
    func handleEventsForBackgroundURLSession(
        identifier: String,
        completionHandler: @escaping () -> Void
    ) {
        // Store completion handler for later
        completionHandlers[identifier] = completionHandler
        
        // Re-create background session
        setupBackgroundSession()
    }
    
    // MARK: - Rust Communication
    
    /**
     * Poll for TransferStateChanged events from Rust
     * Call this regularly from UI or background refresh
     */
    func pollRustEvents() {
        DispatchQueue.global(qos: .background).async {
            while true {
                let eventBytes = hubPollEvent()
                
                if !eventBytes.isEmpty {
                    do {
                        let rustEvent = try RustEvent(serializedData: eventBytes)
                        
                        if case .transferStateChanged(let state) = rustEvent.event {
                            DispatchQueue.main.async {
                                self.handleTransferStateChange(state)
                            }
                        }
                    } catch {
                        print("Failed to parse Rust event: \(error)")
                    }
                }
                
                // Small delay to prevent busy-waiting
                Thread.sleep(forTimeInterval: 0.1)
            }
        }
    }
    
    private func notifyRustOfCompletion(_ state: TransferStateChanged) {
        // Rust handles finalization, integrity checks, cleanup
        // This re-entry point is where Rust finalizes the transfer
        
        // Create finalization command
        let command = UiCommand {
            $0.acceptFile = AcceptFileRequest.with {
                $0.transferID = state.transferId
                $0.accept = state.state == .finished
                $0.downloadPath = ""
            }
        }
        
        _ = hubSendCommand(try! command.serializedData())
    }
    
    // MARK: - Notifications
    
    private func postTransferNotification(title: String, body: String) {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.sound = .default
        
        let request = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil
        )
        
        UNUserNotificationCenter.current().add(request)
    }
}

// MARK: - Transfer State Model

private struct TransferState {
    let id: String
    let fileName: String
    let totalBytes: UInt64
    let direction: TransferDirection
    let localUrl: String  // Rust handoff server URL (http://127.0.0.1:PORT/handoff/FILE_ID)
    var bytesTransferred: UInt64 = 0
    var progress: Double = 0.0
}

// MARK: - URLSession Delegate

extension BackgroundTransferManager: URLSessionDelegate {
    
    func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) {
        // Called when all background tasks complete
        // Call stored completion handlers
        
        for (_, handler) in completionHandlers {
            DispatchQueue.main.async {
                handler()
            }
        }
        completionHandlers.removeAll()
    }
}

extension BackgroundTransferManager: URLSessionTaskDelegate {
    
    func urlSession(
        _ session: URLSession,
        task: URLSessionTask,
        didCompleteWithError error: Error?
    ) {
        // Handle completion/failure of background tasks
        if let error = error {
            print("Background transfer failed: \(error)")
        }
    }
    
    func urlSession(
        _ session: URLSession,
        task: URLSessionTask,
        didSendBodyData bytesSent: Int64,
        totalBytesSent: Int64,
        totalBytesExpectedToSend: Int64
    ) {
        // Track upload progress
        let progress = Double(totalBytesSent) / Double(totalBytesExpectedToSend)
        
        // Update UI/notification
        DispatchQueue.main.async {
            // Update notification with progress
        }
    }
}

// MARK: - AppDelegate Integration

/**
 * Add to AppDelegate.swift:
 * 
 * func application(_ application: UIApplication,
 *                  handleEventsForBackgroundURLSession identifier: String,
 *                  completionHandler: @escaping () -> Void) {
 *     BackgroundTransferManager.shared.handleEventsForBackgroundURLSession(
 *         identifier: identifier,
 *         completionHandler: completionHandler
 *     )
 * }
 */
